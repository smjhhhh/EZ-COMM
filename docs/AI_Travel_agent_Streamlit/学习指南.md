# 🎓 AI 旅行代理学习指南

## 📖 学习路径概览

本指南将带您从零开始，逐步深入理解整个项目的代码和设计思路。

### 学习路线图

```
第一阶段: 基础概念 (1-2 小时)
  ├── Streamlit 基础
  ├── 环境变量管理
  └── Python 装饰器

第二阶段: AI 框架入门 (2-3 小时)
  ├── LangChain 简介
  ├── 工具（Tools）概念
  └── 大语言模型调用

第三阶段: 核心功能实现 (3-4 小时)
  ├── 自定义工具开发
  ├── 系统提示词设计
  └── 会话状态管理

第四阶段: 高级特性 (2-3 小时)
  ├── LangGraph 状态图
  ├── 工具链编排
  └── 错误处理策略

第五阶段: 实战练习 (3-5 小时)
  ├── 添加新功能
  ├── 性能优化
  └── 部署上线
```

---

## 🌟 第一阶段: 基础概念

### 1.1 Streamlit 快速入门

#### Streamlit 是什么？

Streamlit 是一个 Python Web 框架，让您可以用纯 Python 代码创建漂亮的 Web 应用，无需学习 HTML/CSS/JavaScript。

#### 最简单的 Streamlit 应用

创建 `hello.py`:

```python
import streamlit as st

# 这就是一个完整的 Web 应用！
st.title("我的第一个 Streamlit 应用")
st.write("Hello World!")
```

运行:
```bash
streamlit run hello.py
```

**思考**: 为什么只需要这几行代码就能创建 Web 应用？
- Streamlit 自动处理了服务器、路由、渲染等复杂工作
- 代码从上到下执行，每次用户交互都会重新运行整个脚本

#### 基本组件实践

```python
import streamlit as st

# 1. 文本显示
st.title("🌍 标题")
st.header("二级标题")
st.subheader("三级标题")
st.text("普通文本")
st.markdown("**粗体** 和 *斜体*")

# 2. 输入组件
name = st.text_input("你的名字是?")
age = st.slider("你的年龄?", 0, 100, 25)
agree = st.checkbox("我同意")

# 3. 显示变量
st.write(f"你好, {name}! 你 {age} 岁了。")

# 4. 按钮
if st.button("点击我"):
    st.success("按钮被点击了!")
    st.balloons()  # 彩蛋：放气球动画
```

**练习 1**:
创建一个简单的 BMI 计算器:
- 输入身高（厘米）
- 输入体重（公斤）
- 点击按钮计算 BMI
- 显示结果和健康建议

<details>
<summary>💡 参考答案</summary>

```python
import streamlit as st

st.title("BMI 计算器")

height = st.number_input("身高 (cm)", 100, 250, 170)
weight = st.number_input("体重 (kg)", 30, 200, 70)

if st.button("计算 BMI"):
    height_m = height / 100
    bmi = weight / (height_m ** 2)

    st.metric("您的 BMI", f"{bmi:.2f}")

    if bmi < 18.5:
        st.info("体重偏轻")
    elif bmi < 24:
        st.success("体重正常")
    elif bmi < 28:
        st.warning("体重偏重")
    else:
        st.error("肥胖")
```
</details>

---

### 1.2 会话状态 (Session State)

#### 为什么需要 Session State？

Streamlit 脚本每次交互都会重新运行，变量会丢失。Session State 可以在多次运行间保持数据。

#### 基本用法

```python
import streamlit as st

# 初始化 session state
if 'count' not in st.session_state:
    st.session_state.count = 0

# 显示当前计数
st.write(f"计数: {st.session_state.count}")

# 按钮增加计数
if st.button("加 1"):
    st.session_state.count += 1
    st.rerun()  # 重新运行脚本以更新显示
```

**关键概念**:
- `st.session_state` 是一个类似字典的对象
- 数据在用户会话期间持久化
- 每个用户有独立的 session state

#### 在旅行代理中的应用

在 `streamlit_app.py:26-29`:

```python
# 初始化 session state
if 'travel_agent' not in st.session_state:
    st.session_state.travel_agent = None  # 存储 AI 代理实例
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []    # 存储对话历史
```

**设计思路**:
- `travel_agent`: 只初始化一次，避免重复加载（耗时）
- `chat_history`: 保存所有对话，可以回顾历史记录

**练习 2**:
创建一个简单的待办事项应用:
- 添加新任务
- 显示所有任务
- 删除任务
- 使用 session state 保存任务列表

<details>
<summary>💡 参考答案</summary>

```python
import streamlit as st

st.title("📝 待办事项")

# 初始化任务列表
if 'todos' not in st.session_state:
    st.session_state.todos = []

# 添加新任务
new_todo = st.text_input("新任务")
if st.button("添加") and new_todo:
    st.session_state.todos.append(new_todo)
    st.rerun()

# 显示所有任务
st.subheader("任务列表")
for i, todo in enumerate(st.session_state.todos):
    col1, col2 = st.columns([4, 1])
    with col1:
        st.write(f"{i+1}. {todo}")
    with col2:
        if st.button("删除", key=f"del_{i}"):
            st.session_state.todos.pop(i)
            st.rerun()
```
</details>

---

### 1.3 环境变量与安全

#### 为什么使用环境变量？

**问题**: 如果直接在代码中写 API Key:
```python
api_key = "sk-proj-abc123..."  # ❌ 危险！
```

**风险**:
- 提交到 Git 后，全世界都能看到
- API Key 被盗用，产生巨额费用
- 安全漏洞

#### 正确做法: 使用 .env 文件

**步骤 1**: 创建 `.env` 文件
```env
OPENAI_API_KEY=sk-proj-your_real_key_here
SERPER_API_KEY=your_serper_key_here
```

**步骤 2**: 在代码中读取
```python
from dotenv import load_dotenv
import os

# 加载 .env 文件
load_dotenv()

# 读取环境变量
api_key = os.getenv("OPENAI_API_KEY")
print(f"API Key: {api_key[:10]}...")  # 只显示前 10 个字符
```

**步骤 3**: 添加到 `.gitignore`
```
.env
```

#### 在旅行代理中的应用

在 `streamlit_app.py:113`:

```python
# 优先从 Streamlit secrets 读取，回退到环境变量
openai_api_key = st.secrets.get("OPENAI_API_KEY") or os.getenv("OPENAI_API_KEY")

if not openai_api_key:
    st.error("❌ OpenAI API key not found.")
    return None
```

**设计思路**:
1. **本地开发**: 使用 `.env` 文件
2. **云端部署**: 使用 Streamlit Secrets
3. **安全降级**: 如果都没有，显示友好错误

**练习 3**:
创建一个天气应用，安全地使用 API Key:
1. 创建 `.env` 文件存储 API Key
2. 读取并调用天气 API
3. 如果 Key 不存在，显示错误提示

---

### 1.4 Python 装饰器 (@tool)

#### 装饰器是什么？

装饰器是一个函数，可以修改或增强另一个函数的行为。

#### 最简单的装饰器

```python
def my_decorator(func):
    def wrapper():
        print("函数执行前")
        func()
        print("函数执行后")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

# 调用
say_hello()

# 输出:
# 函数执行前
# Hello!
# 函数执行后
```

**等价于**:
```python
def say_hello():
    print("Hello!")

say_hello = my_decorator(say_hello)
```

#### LangChain 的 @tool 装饰器

在 `streamlit_app.py:32-35`:

```python
from langchain.tools import tool

@tool
def addition(a: int, b: int) -> int:
    """Add two integers."""
    return a + b
```

**@tool 装饰器做了什么**:
1. 读取函数签名（参数类型、返回类型）
2. 读取文档字符串（描述功能）
3. 将普通 Python 函数转换为 LangChain Tool 对象
4. AI 可以理解并调用这个工具

**关键要素**:
- **类型注解** (`a: int, b: int -> int`): 告诉 AI 参数类型
- **文档字符串** (`"""Add two integers."""`): 告诉 AI 工具用途
- **返回值**: 工具执行的结果

**练习 4**:
创建以下工具，并测试:
1. `get_current_time()`: 返回当前时间
2. `celsius_to_fahrenheit(celsius: float)`: 温度转换
3. `is_prime(n: int)`: 判断是否为质数

<details>
<summary>💡 参考答案</summary>

```python
from langchain.tools import tool
from datetime import datetime

@tool
def get_current_time() -> str:
    """Get the current time."""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

@tool
def celsius_to_fahrenheit(celsius: float) -> float:
    """Convert Celsius to Fahrenheit."""
    return celsius * 9/5 + 32

@tool
def is_prime(n: int) -> bool:
    """Check if a number is prime."""
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# 测试
print(get_current_time.name)  # 'get_current_time'
print(get_current_time.description)  # 'Get the current time.'
print(get_current_time.invoke({}))  # '2025-10-17 10:30:45'
```
</details>

---

## 🤖 第二阶段: AI 框架入门

### 2.1 LangChain 简介

#### LangChain 是什么？

LangChain 是一个构建 AI 应用的框架，简化了与大语言模型 (LLM) 交互的复杂性。

**类比**:
- **传统方式**: 直接调用 OpenAI API = 自己组装电脑
- **LangChain**: 使用框架 = 买组装好的品牌机

#### 核心概念

1. **LLM (Language Model)**: 语言模型，如 GPT-4
2. **Prompt**: 提示词，告诉 AI 要做什么
3. **Tools**: 工具，AI 可以调用的函数
4. **Chains**: 链，多个步骤的组合
5. **Agents**: 代理，能自主决策的 AI

#### 最简单的 LangChain 应用

```python
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
import os

# 1. 初始化模型
llm = ChatOpenAI(
    model="gpt-4o",
    api_key=os.getenv("OPENAI_API_KEY")
)

# 2. 发送消息
response = llm.invoke([
    HumanMessage(content="什么是 Python?")
])

# 3. 获取回复
print(response.content)
```

**输出**:
```
Python 是一种高级编程语言，以其简洁的语法和强大的功能而闻名...
```

#### 添加系统提示词

```python
from langchain_core.messages import SystemMessage, HumanMessage

messages = [
    SystemMessage(content="你是一个幽默的 Python 老师，用比喻来解释概念。"),
    HumanMessage(content="什么是变量?")
]

response = llm.invoke(messages)
print(response.content)
```

**输出**:
```
想象变量是一个盒子，你可以在盒子里放东西（数据），
还可以给盒子贴个标签（变量名）。需要的时候，
看标签就知道盒子里是什么了！📦
```

**练习 5**:
创建不同性格的 AI 助手:
1. 严肃的老师
2. 幽默的朋友
3. 诗意的作家

通过修改 SystemMessage 实现不同风格。

---

### 2.2 工具 (Tools) 深入理解

#### 为什么需要工具？

**问题**: GPT-4 的知识截止到 2024 年初
- 不知道今天的天气
- 不知道实时股票价格
- 不能做复杂数学计算

**解决**: 给 AI 提供工具！

#### 工具的工作原理

```
用户: "北京今天天气怎么样?"
  ↓
AI 思考: "我需要查询天气，使用 get_weather 工具"
  ↓
调用工具: get_weather("北京")
  ↓
工具返回: "北京，晴，25°C，空气质量良好"
  ↓
AI 整合: "北京今天天气晴朗，温度 25°C，空气质量良好，适合出行！"
  ↓
返回用户
```

#### 创建天气查询工具

在 `streamlit_app.py:54-66`:

```python
@tool
def get_weather(city: str) -> str:
    """Fetches the current weather of the city from OpenWeatherMap."""
    try:
        # 获取 API Key
        weather_api_key = st.secrets.get("OPENWEATHERMAP_API_KEY") or \
                         os.getenv("OPENWEATHERMAP_API_KEY")

        if weather_api_key:
            # 设置环境变量（API wrapper 需要）
            os.environ["OPENWEATHERMAP_API_KEY"] = weather_api_key

            # 创建天气 API wrapper
            weather = OpenWeatherMapAPIWrapper()

            # 调用 API
            return weather.run(city)
        else:
            # 没有 API Key 的友好错误
            return f"Weather API key not available. Cannot get weather for {city}."

    except Exception as e:
        # 捕获所有错误，返回有用的信息
        return f"Weather data unavailable for {city}. Error: {str(e)}"
```

**设计思路解析**:

1. **清晰的文档字符串**: AI 通过这个理解工具用途
   ```python
   """Fetches the current weather of the city from OpenWeatherMap."""
   ```

2. **类型注解**: 告诉 AI 参数和返回值类型
   ```python
   def get_weather(city: str) -> str:
   ```

3. **灵活的配置**: 支持多种配置方式
   ```python
   # 优先级: Streamlit secrets > 环境变量
   weather_api_key = st.secrets.get(...) or os.getenv(...)
   ```

4. **优雅的错误处理**: 不崩溃，返回有用信息
   ```python
   except Exception as e:
       return f"Error: {str(e)}"  # AI 能理解的错误信息
   ```

5. **环境变量设置**: 某些库需要从环境变量读取
   ```python
   os.environ["OPENWEATHERMAP_API_KEY"] = weather_api_key
   ```

#### 工具的最佳实践

**✅ 好的工具**:
```python
@tool
def calculate_mortgage(
    principal: float,
    annual_rate: float,
    years: int
) -> dict:
    """
    Calculate monthly mortgage payment.

    Args:
        principal: Loan amount in dollars
        annual_rate: Annual interest rate (e.g., 5.5 for 5.5%)
        years: Loan term in years

    Returns:
        Dictionary with monthly_payment and total_interest
    """
    monthly_rate = annual_rate / 100 / 12
    num_payments = years * 12

    monthly_payment = principal * (monthly_rate * (1 + monthly_rate)**num_payments) / \
                     ((1 + monthly_rate)**num_payments - 1)

    total_paid = monthly_payment * num_payments
    total_interest = total_paid - principal

    return {
        "monthly_payment": round(monthly_payment, 2),
        "total_interest": round(total_interest, 2),
        "total_paid": round(total_paid, 2)
    }
```

**特点**:
- 详细的文档说明参数和返回值
- 清晰的类型注解
- 返回结构化数据（字典）
- 错误处理（虽然这里没显示）

**❌ 不好的工具**:
```python
@tool
def calc(a, b, op):  # 类型不清晰
    """Do calculation"""  # 描述太模糊
    if op == "+":
        return a + b
    # 没有错误处理，op 是其他值会崩溃
```

**练习 6**:
创建一个货币转换工具:
- 输入: 金额、源货币、目标货币
- 使用固定汇率（或调用实时 API）
- 返回转换后的金额
- 包含完整的类型注解和文档

<details>
<summary>💡 参考答案</summary>

```python
@tool
def convert_currency(
    amount: float,
    from_currency: str,
    to_currency: str
) -> dict:
    """
    Convert amount from one currency to another.

    Args:
        amount: Amount to convert
        from_currency: Source currency code (e.g., 'USD', 'EUR', 'CNY')
        to_currency: Target currency code

    Returns:
        Dictionary with converted amount and exchange rate
    """
    # 简化版：固定汇率（实际应用应调用 API）
    rates = {
        ('USD', 'CNY'): 7.2,
        ('CNY', 'USD'): 0.139,
        ('USD', 'EUR'): 0.92,
        ('EUR', 'USD'): 1.09,
        ('EUR', 'CNY'): 7.83,
        ('CNY', 'EUR'): 0.128,
    }

    # 相同货币
    if from_currency == to_currency:
        return {
            "original_amount": amount,
            "converted_amount": amount,
            "exchange_rate": 1.0,
            "from": from_currency,
            "to": to_currency
        }

    # 查找汇率
    rate_key = (from_currency.upper(), to_currency.upper())
    if rate_key not in rates:
        return {
            "error": f"Exchange rate from {from_currency} to {to_currency} not available"
        }

    rate = rates[rate_key]
    converted = round(amount * rate, 2)

    return {
        "original_amount": amount,
        "converted_amount": converted,
        "exchange_rate": rate,
        "from": from_currency,
        "to": to_currency
    }
```
</details>

---

### 2.3 将工具绑定到 LLM

#### 基本流程

在 `streamlit_app.py:172-176`:

```python
# 1. 定义所有工具
tools = [
    addition, multiply, division, substraction,  # 数学工具
    get_weather,                                 # 天气工具
    search_google, search_duck,                  # 搜索工具
    repl_tool,                                   # Python REPL
    youtube_search                               # 视频搜索
]

# 2. 将工具绑定到 LLM
llm_with_tools = llm.bind_tools(tools)
```

**bind_tools 做了什么**:
1. 将工具列表转换为 JSON Schema
2. 告诉 GPT-4 有哪些工具可用
3. GPT-4 可以决定何时调用哪个工具

#### 简单示例

```python
from langchain_openai import ChatOpenAI
from langchain.tools import tool

@tool
def get_current_time() -> str:
    """Get the current time."""
    from datetime import datetime
    return datetime.now().strftime("%H:%M:%S")

@tool
def add_numbers(a: int, b: int) -> int:
    """Add two numbers."""
    return a + b

# 绑定工具
llm = ChatOpenAI(model="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))
llm_with_tools = llm.bind_tools([get_current_time, add_numbers])

# 调用
response = llm_with_tools.invoke([
    HumanMessage(content="现在几点了?")
])

print(response)
```

**输出** (简化):
```python
AIMessage(
    content='',
    tool_calls=[
        {
            'name': 'get_current_time',
            'args': {},
            'id': 'call_abc123'
        }
    ]
)
```

**注意**: AI 返回的是**工具调用请求**，而不是最终答案。我们需要:
1. 检测到 tool_calls
2. 执行工具
3. 将结果返回给 AI
4. AI 生成最终答案

这就是为什么需要 LangGraph！

---

## 🎯 第三阶段: 核心功能实现

### 3.1 系统提示词设计艺术

系统提示词是 AI 的"工作说明书"，设计得好，AI 就能准确完成任务。

#### 在旅行代理中的系统提示词

在 `streamlit_app.py:129-169`:

```python
system_prompt = SystemMessage("""
You are a professional AI Travel Agent. You MUST follow this EXACT process for every travel query:

STEP 1: ALWAYS call get_weather tool first for the destination city

STEP 2: ALWAYS call search_google or search_duck to find:
   - Hotels with specific prices per night
   - Top attractions with entry fees
   - Restaurants with price ranges
   - Transportation options with costs
   - CURRENCY CONVERSION: If user needs different currency, search for:
     "current exchange rate [from_currency] to [to_currency] today"

STEP 3: ALWAYS use arithmetic tools (addition, multiply) to calculate:
   - Hotel cost = daily_rate × number_of_days
   - Total food cost = daily_food_budget × number_of_days
   - Total attraction costs = sum of all entry fees
   - Currency conversion = amount × exchange_rate (from search)
   - Grand total = hotel + food + attractions + transport

STEP 4: ALWAYS call youtube_search for relevant travel videos

STEP 5: Create detailed day-by-day itinerary with REAL costs from your searches

MANDATORY RULES:
- For currency conversion: SEARCH for current exchange rates, don't guess
- Use ACTUAL data from tool calls, never make up prices
- Show detailed cost breakdown with calculations
- Include weather information from the weather tool
- Provide YouTube video links from your search

FORMAT your response as:
## 🌤️ Weather Information
## 💱 Currency Conversion
## 🏛️ Attractions & Activities
## 🏨 Hotels & Accommodation
## 📅 Daily Itinerary
## 💰 Cost Breakdown
## 🎥 YouTube Resources
## 📋 Summary
""")
```

#### 系统提示词设计原则

**1. 明确角色定位**
```python
"You are a professional AI Travel Agent."
```
- 告诉 AI 它是谁
- 设定专业领域

**2. 清晰的步骤指示**
```python
"STEP 1: ALWAYS call get_weather tool first"
"STEP 2: ALWAYS call search_google..."
```
- 使用 "ALWAYS"、"MUST" 等强制性词汇
- 按顺序列出步骤
- 每个步骤都很具体

**3. 具体的规则**
```python
"MANDATORY RULES:
- For currency conversion: SEARCH for current exchange rates, don't guess
- Use ACTUAL data from tool calls, never make up prices"
```
- 防止 AI "幻觉"（编造信息）
- 强调使用真实数据

**4. 格式要求**
```python
"FORMAT your response as:
## 🌤️ Weather Information
## 💱 Currency Conversion"
```
- 统一输出格式
- 提升用户体验

#### 提示词优化技巧

**❌ 模糊的提示词**:
```python
"帮用户规划旅行"
```
**问题**:
- AI 不知道要做什么
- 可能忘记查天气
- 可能编造价格

**✅ 清晰的提示词**:
```python
"You are a travel agent. Follow these steps:
1. Call get_weather for the destination
2. Search for hotel prices
3. Calculate total cost
4. Return a detailed itinerary"
```

**练习 7**:
为以下场景设计系统提示词:
1. 健身教练 AI（制定训练计划）
2. 营养师 AI（设计饮食方案）
3. 学习助手 AI（制定学习计划）

要求:
- 明确角色
- 3-5 个步骤
- 2-3 条规则
- 输出格式

---

### 3.2 会话历史管理

#### 为什么需要历史记录？

```
用户: "我想去巴黎"
AI: "好的，给你规划巴黎行程..."

用户: "那里的天气怎么样?"
AI: "你想去哪里？"  ❌ AI 忘记了之前的对话
```

**解决**: 保存对话历史

#### 实现方式

在 `streamlit_app.py:29`:

```python
if 'chat_history' not in st.session_state:
    st.session_state.chat_history = []
```

在 `streamlit_app.py:305-308`:

```python
# 保存到历史记录
st.session_state.chat_history.append({
    "query": query,
    "response": final_response
})
```

#### 完整示例: 带历史的聊天应用

```python
import streamlit as st
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, AIMessage, SystemMessage

# 初始化
if 'messages' not in st.session_state:
    st.session_state.messages = []

llm = ChatOpenAI(model="gpt-4o", api_key=os.getenv("OPENAI_API_KEY"))

st.title("💬 聊天应用")

# 显示历史消息
for msg in st.session_state.messages:
    if isinstance(msg, HumanMessage):
        st.chat_message("user").write(msg.content)
    elif isinstance(msg, AIMessage):
        st.chat_message("assistant").write(msg.content)

# 用户输入
if prompt := st.chat_input("说点什么..."):
    # 添加用户消息
    st.session_state.messages.append(HumanMessage(content=prompt))
    st.chat_message("user").write(prompt)

    # 获取 AI 回复
    with st.chat_message("assistant"):
        with st.spinner("思考中..."):
            response = llm.invoke(st.session_state.messages)
            st.write(response.content)

    # 添加 AI 消息
    st.session_state.messages.append(AIMessage(content=response.content))
```

**关键点**:
- 使用 `LangChain` 的消息类型
- 完整的对话历史传递给 LLM
- AI 能理解上下文

**练习 8**:
扩展聊天应用:
1. 添加"清空历史"按钮
2. 限制历史记录最多 10 条（节省 token）
3. 添加系统提示词，让 AI 扮演特定角色

---

### 3.3 错误处理策略

#### 为什么需要错误处理？

**现实情况**:
- API 可能失败（网络问题、配额用尽）
- 用户输入可能无效
- 第三方服务可能宕机

**不处理错误的后果**:
```python
weather = OpenWeatherMapAPIWrapper()
result = weather.run(city)  # 如果 API key 无效，程序崩溃
```

#### 错误处理模式

**模式 1: Try-Except-Return**

在 `streamlit_app.py:54-66`:

```python
@tool
def get_weather(city: str) -> str:
    """Fetches the current weather."""
    try:
        weather_api_key = st.secrets.get("OPENWEATHERMAP_API_KEY") or \
                         os.getenv("OPENWEATHERMAP_API_KEY")

        if weather_api_key:
            os.environ["OPENWEATHERMAP_API_KEY"] = weather_api_key
            weather = OpenWeatherMapAPIWrapper()
            return weather.run(city)
        else:
            # 友好错误: API key 缺失
            return f"Weather API key not available. Cannot get weather for {city}."

    except Exception as e:
        # 友好错误: 其他任何问题
        return f"Weather data unavailable for {city}. Error: {str(e)}"
```

**设计思路**:
1. **不抛出异常**: 返回错误信息字符串
2. **AI 友好**: AI 能理解错误，继续工作
3. **多层检查**: 先检查 API key，再尝试调用

**模式 2: Try-Except with Fallback**

在 `streamlit_app.py:68-81`:

```python
@tool
def search_google(query: str) -> str:
    """Fetches details from Google Serper API."""
    try:
        serper_api_key = st.secrets.get("SERPER_API_KEY") or os.getenv("SERPER_API_KEY")
        if serper_api_key:
            os.environ["SERPER_API_KEY"] = serper_api_key
            search_serper = GoogleSerperAPIWrapper()
            return search_serper.run(query)
        else:
            # 回退到 DuckDuckGo
            return search_duck(query)
    except Exception as e:
        return f"Google search unavailable, trying alternative search. Error: {str(e)}"
```

**设计思路**:
- **优雅降级**: 主要服务失败时，使用备用服务
- **用户无感知**: 自动切换，不需要用户干预

**模式 3: User-Facing Error Handling**

在 `streamlit_app.py:278-280`:

```python
if not openai_key:
    st.error("❌ OpenAI API key is required. Please add it to Streamlit secrets.")
    return  # 停止执行
```

**设计思路**:
- **阻断性错误**: 没有 API key 就无法继续
- **明确指引**: 告诉用户如何解决

#### 错误处理最佳实践

```python
@tool
def robust_api_call(param: str) -> dict:
    """A robust API call with proper error handling."""

    # 1. 参数验证
    if not param or len(param) < 2:
        return {
            "error": "Invalid parameter: must be at least 2 characters",
            "status": "validation_error"
        }

    # 2. API Key 检查
    api_key = os.getenv("API_KEY")
    if not api_key:
        return {
            "error": "API key not configured",
            "status": "configuration_error",
            "hint": "Please add API_KEY to your environment variables"
        }

    # 3. API 调用
    try:
        response = call_external_api(param, api_key)
        return {
            "data": response,
            "status": "success"
        }

    except ConnectionError as e:
        # 网络问题
        return {
            "error": f"Network error: {str(e)}",
            "status": "network_error",
            "retry": True
        }

    except ValueError as e:
        # API 返回无效数据
        return {
            "error": f"Invalid response from API: {str(e)}",
            "status": "api_error"
        }

    except Exception as e:
        # 其他未知错误
        return {
            "error": f"Unexpected error: {str(e)}",
            "status": "unknown_error"
        }
```

**练习 9**:
为一个文件读取工具添加完整的错误处理:
- 文件不存在
- 文件权限不足
- 文件内容格式错误
- 文件过大（>10MB）

---

## 🌊 第四阶段: LangGraph 状态图

### 4.1 为什么需要 LangGraph？

#### 问题: 简单的工具调用不够用

```python
# 简单方式
response = llm_with_tools.invoke([HumanMessage("查北京天气")])

# 问题:
# 1. AI 可能需要调用多个工具
# 2. 一个工具的结果可能用于另一个工具
# 3. 需要来回多次对话
```

**示例流程**:
```
用户: "我想去北京旅行 3 天，预算 3000 元"
  ↓
AI: 调用 get_weather("北京")
  ↓
工具返回: "北京，晴，25°C"
  ↓
AI: 调用 search_google("北京酒店价格")
  ↓
工具返回: "经济型酒店 300 元/晚"
  ↓
AI: 调用 multiply(300, 3)  # 计算酒店总价
  ↓
工具返回: 900
  ↓
AI: 调用 substraction(3000, 900)  # 剩余预算
  ↓
工具返回: 2100
  ↓
AI: 生成最终答案
```

**需要一个框架来管理这个复杂流程** → LangGraph

#### LangGraph 是什么？

LangGraph 是一个状态图框架，用于构建复杂的 AI 工作流。

**核心概念**:
- **节点 (Node)**: 执行特定任务的函数
- **边 (Edge)**: 节点之间的连接
- **状态 (State)**: 在节点间传递的数据
- **条件边 (Conditional Edge)**: 根据条件决定下一步

### 4.2 构建简单的状态图

#### 最简单的例子

```python
from langgraph.graph import StateGraph, MessagesState, START, END
from langchain_core.messages import HumanMessage, SystemMessage

# 定义节点函数
def my_node(state: MessagesState):
    """一个简单的节点，添加一条消息"""
    messages = state["messages"]
    # 添加新消息
    response = HumanMessage(content="Hello from node!")
    return {"messages": messages + [response]}

# 构建图
builder = StateGraph(MessagesState)

# 添加节点
builder.add_node("my_node", my_node)

# 添加边
builder.add_edge(START, "my_node")  # 开始 -> my_node
builder.add_edge("my_node", END)     # my_node -> 结束

# 编译
graph = builder.compile()

# 使用
result = graph.invoke({
    "messages": [HumanMessage(content="Hi")]
})

print(result["messages"])
# [HumanMessage("Hi"), HumanMessage("Hello from node!")]
```

**流程图**:
```
START → my_node → END
```

### 4.3 旅行代理的状态图

在 `streamlit_app.py:185-194`:

```python
# 1. 定义节点函数
def function_1(state: MessagesState):
    user_question = state["messages"]
    input_question = [system_prompt] + user_question
    response = llm_with_tools.invoke(input_question)
    return {"messages": [response]}

# 2. 构建状态图
builder = StateGraph(MessagesState)

# 3. 添加节点
builder.add_node("llm_decision_step", function_1)      # LLM 决策节点
builder.add_node("tools", ToolNode(tools))              # 工具执行节点

# 4. 添加边
builder.add_edge(START, "llm_decision_step")            # 开始 → LLM

# 5. 条件边: 根据 LLM 输出决定下一步
builder.add_conditional_edges(
    "llm_decision_step",
    tools_condition  # 如果需要调用工具 → tools 节点，否则 → END
)

builder.add_edge("tools", "llm_decision_step")          # 工具 → LLM (循环)

# 6. 编译
react_graph = builder.compile()
```

**流程图**:
```
START
  ↓
llm_decision_step ←──┐
  ↓ (条件判断)        │
  ├─→ 需要工具? → tools ─┘
  └─→ 不需要? → END
```

#### 详细解析

**1. MessagesState**
```python
class MessagesState:
    messages: list[BaseMessage]  # 存储所有消息
```

**2. function_1 (LLM 决策节点)**
```python
def function_1(state: MessagesState):
    # 获取当前消息
    user_question = state["messages"]

    # 添加系统提示词
    input_question = [system_prompt] + user_question

    # 调用 LLM (带工具)
    response = llm_with_tools.invoke(input_question)

    # 返回新消息
    return {"messages": [response]}
```

**3. ToolNode (工具执行节点)**
```python
ToolNode(tools)  # 自动处理工具调用
```

**功能**:
- 检查 LLM 响应中的 `tool_calls`
- 执行对应的工具
- 将结果包装成 `ToolMessage`

**4. tools_condition (条件函数)**
```python
def tools_condition(state):
    """检查最后一条消息是否包含工具调用"""
    last_message = state["messages"][-1]

    if hasattr(last_message, 'tool_calls') and last_message.tool_calls:
        return "tools"  # 去工具节点
    else:
        return END  # 结束
```

### 4.4 执行流程示例

用户查询: "北京今天天气怎么样?"

```
【第 1 轮】
START → llm_decision_step
  LLM 输出: AIMessage(tool_calls=[{name: 'get_weather', args: {'city': '北京'}}])

条件判断: 有 tool_calls → 前往 tools 节点

【第 2 轮】
tools 节点
  执行: get_weather("北京")
  返回: ToolMessage(content="北京，晴，25°C")

自动返回: llm_decision_step

【第 3 轮】
llm_decision_step
  输入: [
    HumanMessage("北京今天天气怎么样?"),
    AIMessage(tool_calls=[...]),
    ToolMessage("北京，晴，25°C")
  ]

  LLM 输出: AIMessage(content="北京今天天气晴朗，温度 25°C")

条件判断: 无 tool_calls → END

返回给用户: "北京今天天气晴朗，温度 25°C"
```

**关键点**:
- **自动循环**: 工具节点自动返回 LLM 节点
- **状态累积**: 每轮的消息都添加到状态中
- **AI 决策**: LLM 决定何时停止调用工具

### 4.5 实战: 添加新节点

假设我们想添加一个"数据验证"节点，在最终输出前检查数据。

```python
# 1. 定义验证节点
def validation_node(state: MessagesState):
    """验证 AI 输出是否包含必要信息"""
    last_message = state["messages"][-1]
    content = last_message.content

    # 检查是否包含关键信息
    required_keywords = ["天气", "温度"]
    if all(keyword in content for keyword in required_keywords):
        # 验证通过
        return {"messages": [HumanMessage(content="✅ 验证通过")]}
    else:
        # 验证失败，要求 AI 重新生成
        return {"messages": [HumanMessage(content="请提供更详细的天气信息")]}

# 2. 修改图构建
builder = StateGraph(MessagesState)
builder.add_node("llm_decision_step", function_1)
builder.add_node("tools", ToolNode(tools))
builder.add_node("validation", validation_node)  # 新节点

builder.add_edge(START, "llm_decision_step")
builder.add_conditional_edges("llm_decision_step", tools_condition)
builder.add_edge("tools", "llm_decision_step")

# 在结束前添加验证
builder.add_edge("llm_decision_step", "validation")
builder.add_edge("validation", END)

react_graph = builder.compile()
```

**练习 10**:
设计一个新的状态图，包含:
1. LLM 节点
2. 搜索节点
3. 总结节点
4. 翻译节点（如果需要）

流程:
- 用户问题 → LLM 决策
- LLM 调用搜索
- 搜索结果 → 总结节点
- 如果用户要求其他语言 → 翻译节点
- 返回最终结果

---

## 🚀 第五阶段: 实战练习

### 5.1 练习 1: 添加新功能 - 航班搜索

**任务**: 添加一个航班价格查询工具

**步骤**:

#### 1. 创建工具
```python
@tool
def search_flight(
    origin: str,
    destination: str,
    date: str
) -> dict:
    """
    Search for flight prices.

    Args:
        origin: Origin city (e.g., "北京")
        destination: Destination city (e.g., "上海")
        date: Travel date in YYYY-MM-DD format

    Returns:
        Dictionary with flight options and prices
    """
    # 模拟数据（实际应调用航班 API）
    import random

    base_price = random.randint(500, 2000)

    return {
        "origin": origin,
        "destination": destination,
        "date": date,
        "flights": [
            {
                "airline": "东方航空",
                "departure": "08:00",
                "arrival": "10:30",
                "price": base_price
            },
            {
                "airline": "南方航空",
                "departure": "14:00",
                "arrival": "16:30",
                "price": base_price + 200
            },
            {
                "airline": "中国国航",
                "departure": "18:00",
                "arrival": "20:30",
                "price": base_price - 100
            }
        ]
    }
```

#### 2. 注册工具
```python
tools = [
    # ... 现有工具
    search_flight  # 新工具
]
```

#### 3. 更新系统提示词
```python
system_prompt = SystemMessage("""
...
STEP 2.5: If user mentions air travel, call search_flight tool

ADDITIONAL SECTION in output:
## ✈️ Flight Options
...
""")
```

#### 4. 测试
```
用户: "我想从北京飞上海，2025-11-01 出发"
预期输出: 航班选项和价格
```

---

### 5.2 练习 2: 性能优化

**任务**: 减少 API 调用次数和成本

#### 优化 1: 缓存搜索结果

```python
import streamlit as st
from functools import lru_cache

# 方法 1: Streamlit 缓存
@st.cache_data(ttl=3600)  # 缓存 1 小时
def cached_search(query: str) -> str:
    """缓存的搜索函数"""
    search = DuckDuckGoSearchRun()
    return search.invoke(query)

# 方法 2: Python LRU 缓存
@lru_cache(maxsize=100)
def cached_weather(city: str) -> str:
    """缓存的天气查询"""
    weather = OpenWeatherMapAPIWrapper()
    return weather.run(city)

# 在工具中使用
@tool
def get_weather(city: str) -> str:
    """Get weather with caching."""
    return cached_weather(city)
```

#### 优化 2: 减少 Token 使用

```python
# 原来: 2000 tokens
llm = ChatOpenAI(
    model="gpt-4o",
    max_tokens=2000  # 每次最多生成 2000 tokens
)

# 优化: 1000 tokens
llm = ChatOpenAI(
    model="gpt-4o",
    max_tokens=1000  # 减少 50%
)

# 进一步优化: 使用更便宜的模型
llm = ChatOpenAI(
    model="gpt-3.5-turbo",  # 成本降低 90%
    max_tokens=1000
)
```

#### 优化 3: 限制历史记录长度

```python
# 只保留最近 5 轮对话
if len(st.session_state.messages) > 10:  # 5 轮 × 2 条消息
    # 保留系统消息 + 最近 10 条
    st.session_state.messages = (
        [st.session_state.messages[0]] +  # 系统消息
        st.session_state.messages[-10:]    # 最近 10 条
    )
```

---

### 5.3 练习 3: 添加用户认证

**任务**: 添加简单的用户认证

```python
import streamlit as st

def check_password():
    """返回 `True` 如果用户输入了正确的密码."""

    def password_entered():
        """检查密码是否正确."""
        if st.session_state["password"] == "your_secret_password":
            st.session_state["password_correct"] = True
            del st.session_state["password"]  # 删除密码
        else:
            st.session_state["password_correct"] = False

    # 首次访问或密码错误
    if "password_correct" not in st.session_state:
        st.text_input(
            "密码",
            type="password",
            on_change=password_entered,
            key="password",
        )
        return False

    # 密码错误
    elif not st.session_state["password_correct"]:
        st.text_input(
            "密码",
            type="password",
            on_change=password_entered,
            key="password",
        )
        st.error("😕 密码错误")
        return False

    # 密码正确
    else:
        return True

# 在 main 函数开头使用
def main():
    if not check_password():
        st.stop()  # 停止执行

    # 主应用逻辑
    st.title("🌍 AI Travel Agent")
    # ...
```

---

## 📊 学习成果检验

### 知识点清单

完成所有练习后，您应该能够:

**基础 (第一阶段)**
- [ ] 创建 Streamlit 应用
- [ ] 使用 session_state 管理状态
- [ ] 安全地使用环境变量
- [ ] 理解 Python 装饰器

**AI 框架 (第二阶段)**
- [ ] 调用 OpenAI API
- [ ] 使用 LangChain 创建对话
- [ ] 创建自定义工具
- [ ] 将工具绑定到 LLM

**核心功能 (第三阶段)**
- [ ] 设计有效的系统提示词
- [ ] 管理对话历史
- [ ] 实现错误处理
- [ ] 优化用户体验

**高级特性 (第四阶段)**
- [ ] 构建 LangGraph 状态图
- [ ] 理解节点和边的概念
- [ ] 实现条件逻辑
- [ ] 调试复杂工作流

**实战能力 (第五阶段)**
- [ ] 添加新功能
- [ ] 优化性能和成本
- [ ] 部署到生产环境
- [ ] 维护和监控应用

---

## 🎯 下一步学习建议

### 1. 深入 LangChain
- [LangChain 官方文档](https://python.langchain.com)
- 学习 Chain 和 LCEL
- 了解 Memory 和 Retrieval

### 2. 掌握 LangGraph
- [LangGraph 文档](https://langchain-ai.github.io/langgraph/)
- 构建多代理系统
- 实现人机协作

### 3. 提升 Prompt Engineering
- [OpenAI Prompt Engineering Guide](https://platform.openai.com/docs/guides/prompt-engineering)
- Few-shot learning
- Chain-of-thought prompting

### 4. 学习向量数据库
- Pinecone / Weaviate
- 实现 RAG (Retrieval Augmented Generation)
- 构建知识库问答系统

### 5. 项目实战
建议项目:
1. **客服机器人**: 多轮对话 + 知识库
2. **代码助手**: 理解需求 + 生成代码 + 调试
3. **数据分析助手**: 读取数据 + 分析 + 可视化

---

## 💡 学习技巧

### 1. 动手实践
- 每个代码示例都要自己敲一遍
- 修改参数，观察结果变化
- 尝试破坏代码，理解错误

### 2. 阅读源码
```python
# 好奇 ToolNode 如何工作？
from langgraph.prebuilt import ToolNode
import inspect

print(inspect.getsource(ToolNode))
```

### 3. 使用调试工具
```python
# 在关键位置添加打印
def function_1(state: MessagesState):
    print(f"📥 收到消息: {state['messages']}")

    response = llm_with_tools.invoke(...)

    print(f"📤 AI 响应: {response}")
    print(f"🔧 工具调用: {getattr(response, 'tool_calls', None)}")

    return {"messages": [response]}
```

### 4. 建立知识体系
- 创建思维导图
- 写学习笔记
- 教别人（最好的学习方法）

### 5. 加入社区
- [LangChain Discord](https://discord.gg/langchain)
- [Streamlit Forum](https://discuss.streamlit.io/)
- GitHub Discussions

---

## 🎓 结语

恭喜您完成了学习指南！现在您已经具备了:

✅ 构建 AI 应用的基础知识
✅ 使用 LangChain 和 LangGraph 的能力
✅ 设计复杂工作流的思维
✅ 解决实际问题的经验

**记住**:
- 学习是一个渐进的过程，不要着急
- 遇到问题很正常，查文档、问社区
- 最好的学习方式是构建自己的项目

**现在，开始构建您自己的 AI 应用吧！** 🚀

---

**最后更新**: 2025-10-17
**作者**: AI Travel Agent Team
**版本**: 1.0.0
